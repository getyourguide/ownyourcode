var y=Object.defineProperty;var i=(s,e)=>y(s,"name",{value:e,configurable:!0});import{setOutput as d,setFailed as m,getInput as l,getBooleanInput as E,info as a}from"@actions/core";import{context as F,getOctokit as S}from"@actions/github";import _ from"glob-to-regexp";class ${static{i(this,"GitHubService")}constructor(e,t,r){this.octokit=e,this.owner=t,this.repo=r}async getCodeOwnersFile(e,t){try{const{data:r}=await this.octokit.rest.repos.getContent({owner:this.owner,repo:this.repo,ref:e,path:t});if(Array.isArray(r)||r.type!=="file")throw new Error(`File not found or is not a regular file: ${t}`);return Buffer.from(r.content,"base64").toString("utf-8")}catch{throw new Error(`Error reading the CODEOWNERS file ${this.owner}/${this.repo}/${t}
Make sure the file exists and the github token has access to the repo`)}}async getChangedFiles(e){const t=[],r=this.octokit.paginate.iterator(this.octokit.rest.pulls.listFiles,{owner:this.owner,repo:this.repo,pull_number:e,per_page:100});for await(const{data:o}of r)for(const n of o)n.status!=="removed"&&t.push(n.filename);return t}async getAllFiles(e){const{data:t}=await this.octokit.rest.git.getTree({recursive:"true",owner:this.owner,repo:this.repo,tree_sha:`refs/heads/${e}`}),r=[];return t.tree.forEach(o=>{o.type==="blob"&&o.path&&r.push(o.path)}),r}async createComment(e,t){const r={repo:this.repo,owner:this.owner,issue_number:e,body:t};await this.octokit.rest.issues.createComment(r)}async updateComment(e,t){const r={repo:this.repo,owner:this.owner,comment_id:e,body:t};await this.octokit.rest.issues.updateComment(r)}async findPreviousComment(e,t){const{data:r}=await this.octokit.rest.issues.listComments({repo:this.repo,owner:this.owner,per_page:100,issue_number:e}),o=r.find(n=>n.body?.startsWith(t));return o?{id:o.id,content:o.body}:void 0}}function k(s){return s.replace(/[/\-\\^$*+?.()|[\]{}]/g,"\\$&")}i(k,"escapeRegex");class N{static{i(this,"CodeOwners")}ruleset;codeownersPath;constructor(e,t){this.ruleset=e.split(`
`).map(r=>r.split(/\s+/).filter(o=>o)).filter(r=>r[0]&&r[0]!=="#"&&r[0]!=="*").map(r=>{const[o,n]=r,c=o.replace(/^\/+/,"");return[_(c,{globstar:!0,extended:!0,flags:"g"}),n]}),this.codeownersPath=k(t)}isCovered(e){return e.match(this.codeownersPath)?!0:this.ruleset.some(t=>t?.[0]?e.match(t[0]):!1)}bulkIsCovered(e){return e.map(t=>this.isCovered(t))}}const p=`## OwnYourCode
`;class R{static{i(this,"PrHandler")}constructor(e,t){this.githubService=e,this.prNumber=t}async getCodeOwnersFile(e){const t=`pull/${this.prNumber}/head`;return await this.githubService.getCodeOwnersFile(t,e)}async getChangedFiles(){return await this.githubService.getChangedFiles(this.prNumber)}async createOrUpdatePrComment(e){const t=await this.githubService.findPreviousComment(this.prNumber,p);t&&await this.githubService.updateComment(t.id,this.buildCommentBody(e)),e.length&&!t&&await this.githubService.createComment(this.prNumber,this.buildCommentBody(e))}buildCommentBody(e){return e.length?`${p}\u274C The following files do not have an owner in the CODEOWNERS file:
* ${e.join(`
* `)}

**Please assign an owner to these files.**`:`${p}\u2705 All files have an owner in the CODEOWNERS file. Good job!`}}class P{static{i(this,"BranchHandler")}constructor(e,t){this.githubService=e,this.branch=t}async getCodeOwnersFile(e){const t=`refs/heads/${this.branch}`;return await this.githubService.getCodeOwnersFile(t,e)}async getChangedFiles(){return await this.githubService.getAllFiles(this.branch)}async createOrUpdatePrComment(e){return Promise.resolve()}}async function A(){try{const{githubToken:s,codeownersPath:e,prNumber:t,failOnMissing:r,branch:o}=B(),{repo:n,owner:c}=F.repo,h=S(s),f=new $(h,c,n);M(n,e,r,o,t);const u=t?new R(f,t):new P(f,o),b=await u.getCodeOwnersFile(e),g=await u.getChangedFiles(),O=new N(b,e),{noOwnerArr:w,failed:v}=T(g,O,r);await u.createOrUpdatePrComment(w),d("total_scanned_files",g.length),d("total_orphan_files",w.length),d("failed",v)}catch(s){m(`OwnYourCode action failed: ${s.message}`)}}i(A,"run");function B(){const s=l("GITHUB_TOKEN"),e=l("CODEOWNERS_PATH"),t=+l("PR_NUMBER"),r=l("BRANCH"),o=E("FAIL_ON_MISSING_CODEOWNERS");return{githubToken:s,codeownersPath:e,prNumber:t,failOnMissing:o,branch:r}}i(B,"loadInputs");function M(s,e,t,r,o){a("----------- OwnYourCode ----------"),a(`Repo: ${s}`),a(`File: ${e}`),a(`Fail on missing: ${t}`),a(`Mode: ${o?"Check PR changed files":"Check all branch files"}`),r&&a(`Branch: ${r}`),o&&a(`PR: #${o}`),a(`----------------------------------
`)}i(M,"welcomeMessage");function T(s,e,t){let r=!1;const o=[],n=[];return s.forEach(c=>{const h=e.isCovered(c);h?o.push(c):n.push(c),r=r||!h}),C("List of covered files \u2705",o),C("List of files not covered \u274C",n),r&&t&&m("Some files do not have an owner, please define one in CODEOWNERS file"),{noOwnerArr:n,failed:r}}i(T,"checkFilesOwners");function C(s,e){e.length&&(a(s),e.forEach(t=>a(t)))}i(C,"printResults"),A();
//# sourceMappingURL=index.js.map
